<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>OFEM Dashboard</title>
  <link rel="stylesheet" href="css/app.css">
</head>
<body>
  <header class="site-header">
    <nav class="nav-bar">
      <a href="index.html">Dashboard</a>
      <a href="ppv.html">PPV Manager</a>
      <a href="history.html">Message History</a>
      <a href="queue.html">Scheduled Queue</a>
      <a href="follow.html" class="btn btn-primary">Follow Fans and Followers</a>
    </nav>
  </header>
  <h1>OnlyFans Express Messenger (OFEM)</h1>
  <p class="instructions">
    Step 1: <strong>Update Fan List</strong> to fetch followers and fans.<br>
    Step 2: <strong>Update Parker Names</strong> to generate and apply names.
  </p>
  <p>
    <button id="refreshBtn" class="btn btn-primary">Update Fan List</button>
    <button id="updateBtn" class="btn btn-primary">Update Parker Names</button>
    <button class="btn btn-primary" onclick="location.href='ppv.html'">PPV Manager</button>
    <a href="history.html" target="_blank">Message History</a>
    <a href="queue.html" target="_blank">Scheduled Queue</a>
  </p>
  <div id="messageSection" class="message-section">
    <input type="text" id="greeting" class="form-input" value="Hi {parker_name}!" />
    <div id="toolbar">
      <select id="sizeSelect" class="form-input">
        <option value="default">Default</option>
        <option value="sm">Smallest</option>
        <option value="s">Small</option>
        <option value="l">Large</option>
        <option value="lg">Largest</option>
      </select>
      <select id="colorSelect" class="form-input">
        <option value="">Default</option>
        <option value="gray">Gray</option>
        <option value="blue1">Blue 1</option>
        <option value="blue2">Blue 2</option>
      </select>
      <button id="boldBtn" type="button" class="btn btn-secondary">Bold</button>
      <button id="italicBtn" type="button" class="btn btn-secondary">Italic</button>
      <select id="placeholderSelect" class="form-input">
        <option value="">Insert Placeholder</option>
        <option value="{parker_name}">{parker_name}</option>
        <option value="{username}">{username}</option>
        <option value="{location}">{location}</option>
        <option value="{name}">{name}</option>
        <option value="[name]">[name]</option>
      </select>
    </div>
    <div id="message" contenteditable="true" class="m-editor-fs__default message-editor"></div>
    <div id="vaultSection" class="vault-section">
      <button id="loadVaultBtn" type="button" class="btn btn-primary">Load Vault Media</button>
      <div id="vaultMediaList" class="vault-media-list"></div>
      <div class="mt-5">
        <label>Price: <input type="number" id="price" min="0" step="0.01" class="form-input w-80"></label>
        <input type="text" id="lockedText" placeholder="Locked text" class="form-input w-200" />
      </div>
    </div>
    <div class="schedule-section">
      <label>Schedule Time: <input type="datetime-local" id="scheduledTime" class="form-input" /></label>
    </div>
    <button id="sendBtn" class="btn btn-primary">Send Personalized DM to All Fans</button>
    <button id="scheduleBtn" type="button" class="btn btn-primary">Schedule Message</button>
    <button id="abortBtn" class="btn btn-secondary" disabled>Abort Sending</button>
    <button id="clearStatusBtn" type="button" class="btn btn-secondary">Clear Status</button>
    <button id="downloadBtn" type="button" class="btn btn-secondary">Download Results</button>
  </div>
  <div id="statusMsg" class="status-msg"></div>
  <table id="fansTable" class="form-table">
    <thead>
      <tr>
        <th>Username</th>
        <th>Profile Name</th>
        <th>Parker Name</th>
        <th>Status</th>
        <th>Save</th>
      </tr>
    </thead>
    <tbody id="fansTableBody">
      <!-- Fan rows will be inserted here -->
    </tbody>
  </table>

  <script src="editor.js"></script>
  <script src="results.js"></script>
  <script>
    let fansData = [];
    let sendingInProgress = false;
    let abortFlag = false;

    // Simple HTML escape helper to prevent injection when using innerHTML
    function escapeHtml(str) {
      return str.replace(/[&<>"']/g, c => ({
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#39;'
      }[c]));
    }

    async function fetchFans() {
      try {
        const res = await fetch('/api/fans');
        if (!res.ok) {
          console.error('Failed to fetch fans list');
          return;
        }
        const data = await res.json();
        fansData = data.fans || [];
        renderFansTable();
      } catch (err) {
        console.error('Error fetching fans:', err);
      }
    }

    async function loadVaultMedia() {
      try {
        const res = await fetch('/api/vault-media');
        if (!res.ok) return;
        const data = await res.json();
        const items = Array.isArray(data) ? data : (data.list || data.results || data.media || data.data || []);
        const container = document.getElementById('vaultMediaList');
        container.innerHTML = '';
        for (const m of items) {
          const div = document.createElement('div');
          const mediaCb = document.createElement('input');
          mediaCb.type = 'checkbox';
          mediaCb.className = 'mediaCheckbox';
          mediaCb.value = m.id;
          div.appendChild(mediaCb);

          const previewCb = document.createElement('input');
          previewCb.type = 'checkbox';
          previewCb.className = 'previewCheckbox';
          previewCb.value = m.id;
          div.appendChild(previewCb);

          const span = document.createElement('span');
          span.textContent = 'Media ' + m.id;
          div.appendChild(span);

          const thumb = (m.preview && (m.preview.url || m.preview.src)) ||
                       (m.thumb && (m.thumb.url || m.thumb.src));
          if (thumb) {
            const img = document.createElement('img');
            img.src = thumb;
            img.width = 50;
            img.style.marginLeft = '5px';
            div.appendChild(img);
          }
          container.appendChild(div);
        }
      } catch (err) {
        console.error('Error loading vault media:', err);
      }
    }

    function renderFansTable() {
      const tbody = document.getElementById('fansTableBody');
      tbody.innerHTML = '';
      for (const fan of fansData) {
        const id = fan.id;
        const username = fan.username || '';
        const profileName = fan.name || '';
        const parkerName = fan.parker_name || '';

        const tr = document.createElement('tr');
        tr.id = `fan-${id}`;

        const tdUser = document.createElement('td');
        tdUser.textContent = username;
        tr.appendChild(tdUser);

        const tdProfile = document.createElement('td');
        tdProfile.textContent = profileName;
        tr.appendChild(tdProfile);

        const tdParker = document.createElement('td');
        const input = document.createElement('input');
        input.type = 'text';
        input.id = `name-${id}`;
        input.value = parkerName;
        if (!parkerName) {
          input.placeholder = 'Pending';
        }
        input.className = 'form-input';
        tdParker.appendChild(input);
        tr.appendChild(tdParker);

        const tdStatus = document.createElement('td');
        const statusSpan = document.createElement('span');
        statusSpan.id = `status-${id}`;
        tdStatus.appendChild(statusSpan);
        tr.appendChild(tdStatus);

        const tdSave = document.createElement('td');
        const btn = document.createElement('button');
        btn.textContent = 'Save';
        btn.className = 'btn btn-secondary';
        btn.addEventListener('click', () => updateName(String(id)));
        tdSave.appendChild(btn);
        tr.appendChild(tdSave);

        tbody.appendChild(tr);
      }
      // Enable the Send button only if there are fans listed
      document.getElementById('sendBtn').disabled = (fansData.length === 0);
    }

    function setStatusDot(fanId, colorClass) {
      const statusEl = document.getElementById('status-' + fanId);
      if (statusEl) {
        statusEl.innerHTML = '<span class="dot ' + escapeHtml(colorClass) + '"></span>';
      }
    }

    async function updateName(fanId) {
      const input = document.getElementById('name-' + fanId);
      if (!input) return;
      const newName = input.value.trim();
      if (!newName) {
        alert('Name cannot be empty.');
        return;
      }
      try {
        const res = await fetch('/api/fans/' + fanId, {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ parker_name: newName })
        });
        if (!res.ok) {
          const errText = await res.text();
          alert('Failed to save name: ' + errText);
          return;
        }
        // Highlight the input briefly to show it was saved
        input.style.backgroundColor = '#c8ffc8';
        setTimeout(() => { input.style.backgroundColor = ''; }, 1000);
        console.log('Parker name updated for fan ' + fanId);
        // Update our local data as well
        const fan = fansData.find(f => f.id == fanId);
        if (fan) {
          fan.parker_name = newName;
        }
      } catch (err) {
        console.error('Error updating name:', err);
        alert('Error: ' + err.message);
      }
    }

    async function refreshFansList() {
      const refreshBtn = document.getElementById('refreshBtn');
      const updateBtn = document.getElementById('updateBtn');
      const sendBtn = document.getElementById('sendBtn');
      refreshBtn.disabled = true;
      updateBtn.disabled = true;
      sendBtn.disabled = true;
      document.getElementById('statusMsg').innerText = 'Updating fan list...';
      try {
        const res = await fetch('/api/refreshFans', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: '{}'
        });
        if (!res.ok) {
          const errText = await res.text();
          document.getElementById('statusMsg').innerText = 'Fan list update failed: ' + errText;
        } else {
          const data = await res.json();
          fansData = data.fans || [];
          renderFansTable();
          document.getElementById('statusMsg').innerText = 'Loaded ' + fansData.length + ' fans.';
        }
      } catch (err) {
        console.error('Update fan list error:', err);
        document.getElementById('statusMsg').innerText = 'Fan list update failed: ' + err;
      } finally {
        refreshBtn.disabled = false;
        updateBtn.disabled = false;
        sendBtn.disabled = (fansData.length === 0);
      }
    }

    async function updateParkerNames() {
      const refreshBtn = document.getElementById('refreshBtn');
      const updateBtn = document.getElementById('updateBtn');
      const sendBtn = document.getElementById('sendBtn');
      refreshBtn.disabled = true;
      updateBtn.disabled = true;
      sendBtn.disabled = true;
      document.getElementById('statusMsg').innerText = 'Updating Parker names...';

      const pendingIds = fansData.filter(f => !f.parker_name).map(f => f.id);
      pendingIds.forEach(id => {
        const statusEl = document.getElementById('status-' + id);
        if (statusEl) statusEl.textContent = '⏳';
      });

      let polls = 0;
      const maxPolls = 60;

      const poll = async () => {
        if (pendingIds.length === 0) {
          finish(true);
          return;
        }
        if (polls >= maxPolls) {
          pendingIds.forEach(id => {
            const statusEl = document.getElementById('status-' + id);
            if (statusEl) statusEl.textContent = '❌';
          });
          finish(false);
          return;
        }
        try {
          const [fansRes, statusRes] = await Promise.all([
            fetch('/api/fans'),
            fetch('/api/updateParkerNames/status')
          ]);

          if (fansRes.ok) {
            const data = await fansRes.json();
            fansData = data.fans || [];
            for (const id of pendingIds.slice()) {
              const fan = fansData.find(f => f.id === id);
              if (fan && fan.parker_name) {
                const nameInput = document.getElementById('name-' + id);
                if (nameInput) nameInput.value = fan.parker_name;
                const statusEl = document.getElementById('status-' + id);
                if (statusEl) statusEl.textContent = '✅';
                pendingIds.splice(pendingIds.indexOf(id), 1);
              }
            }
          }

          let inProgress = true;
          if (statusRes.ok) {
            const statusData = await statusRes.json();
            inProgress = statusData.inProgress;
          }
          if (!inProgress) {
            if (pendingIds.length === 0) {
              finish(true);
            } else {
              pendingIds.forEach(id => {
                const statusEl = document.getElementById('status-' + id);
                if (statusEl) statusEl.textContent = '❌';
              });
              finish(false);
            }
            return;
          }
        } catch (err) {
          console.error('Polling error:', err);
        }
        polls++;
        setTimeout(poll, 2000);
      };

      const finish = (success) => {
        refreshBtn.disabled = false;
        updateBtn.disabled = false;
        sendBtn.disabled = (fansData.length === 0);
        document.getElementById('statusMsg').innerText = success ? 'Parker names updated.' : 'Update finished with errors.';
      };

      poll();

      try {
        const res = await fetch('/api/updateParkerNames', { method: 'POST' });
        if (!res.ok) {
          const errText = await res.text();
          document.getElementById('statusMsg').innerText = 'Update failed: ' + errText;
        }
      } catch (err) {
        console.error('Update Parker names error:', err);
        document.getElementById('statusMsg').innerText = 'Update failed: ' + err;
      }
    }

    async function sendMessagesToAll() {
      if (sendingInProgress) return;
      if (fansData.length === 0) {
        alert('No fans to send messages to.');
        return;
      }
      const greeting = document.getElementById('greeting').value;
      const body = document.getElementById('message').innerHTML.trim();
      if (!body) {
        alert('Please enter a message.');
        return;
      }
      const priceVal = document.getElementById('price').value;
      const price = priceVal ? parseFloat(priceVal) : undefined;
      const lockedText = document.getElementById('lockedText').value;
      const mediaFiles = Array.from(document.querySelectorAll('.mediaCheckbox:checked')).map(cb => cb.value);
      const previews = Array.from(document.querySelectorAll('.previewCheckbox:checked')).map(cb => cb.value);
      clearStatusDots();
      sendingInProgress = true;
      abortFlag = false;
      document.getElementById('refreshBtn').disabled = true;
      document.getElementById('updateBtn').disabled = true;
      document.getElementById('sendBtn').disabled = true;
      document.getElementById('abortBtn').disabled = false;
      document.getElementById('statusMsg').innerText = 'Sending messages...';
      let successCount = 0;
      let failCount = 0;
      let totalFailures = 0;

      for (let i = 0; i < fansData.length; i++) {
        const fan = fansData[i];
        const fanId = fan.id;
        if (abortFlag) {
          console.log('Aborting send loop by user request.');
          break;
        }
        try {
          const res = await fetch('/api/sendMessage', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ userId: fanId, greeting, body, price, lockedText, mediaFiles, previews })
          });
          const result = await res.json();
          if (result.success) {
            // Success: mark green
            setStatusDot(fanId, 'green');
            addResult({ fanId, username: fan.username || '', parkerName: fan.parker_name || '', success: true });
            successCount++;
            failCount = 0;  // reset consecutive fail counter on success
          } else {
            // Failure: mark red
            setStatusDot(fanId, 'red');
            addResult({ fanId, username: fan.username || '', parkerName: fan.parker_name || '', success: false, error: result.error || '' });
            failCount++;
            totalFailures++;
            if (failCount >= 10) {
              // 10 consecutive failures -> auto-abort
              abortFlag = true;
              console.log('Auto-abort: 10 consecutive failures.');
              break;
            }
          }
        } catch (err) {
          console.error('Error sending to fan ' + fanId + ':', err);
          // Treat network or unexpected error as failure
          setStatusDot(fanId, 'red');
          addResult({ fanId, username: fan.username || '', parkerName: fan.parker_name || '', success: false, error: err.message });
          failCount++;
          totalFailures++;
          if (failCount >= 10) {
            abortFlag = true;
            console.log('Auto-abort due to consecutive errors.');
            break;
          }
        }
        // Small delay between messages to avoid rate limit issues
        await new Promise(r => setTimeout(r, 500));
      }

      // Finished sending loop
      sendingInProgress = false;
      document.getElementById('abortBtn').disabled = true;
      document.getElementById('refreshBtn').disabled = false;
      document.getElementById('updateBtn').disabled = false;
      document.getElementById('sendBtn').disabled = false;
      if (abortFlag) {
        document.getElementById('statusMsg').innerText = 'Sending aborted. Sent ' + successCount + ' messages, ' + totalFailures + ' failed.';
      } else {
        document.getElementById('statusMsg').innerText = 'Finished sending: ' + successCount + ' succeeded, ' + totalFailures + ' failed.';
      }
    }

    async function scheduleMessages() {
      if (fansData.length === 0) {
        alert('No fans to send messages to.');
        return;
      }
      const greeting = document.getElementById('greeting').value;
      const body = document.getElementById('message').innerHTML.trim();
      if (!body) {
        alert('Please enter a message.');
        return;
      }
      const scheduledTime = document.getElementById('scheduledTime').value;
      if (!scheduledTime) {
        alert('Please choose a schedule time.');
        return;
      }
      const priceVal = document.getElementById('price').value;
      const price = priceVal ? parseFloat(priceVal) : undefined;
      const lockedText = document.getElementById('lockedText').value;
      const mediaFiles = Array.from(document.querySelectorAll('.mediaCheckbox:checked')).map(cb => cb.value);
      const previews = Array.from(document.querySelectorAll('.previewCheckbox:checked')).map(cb => cb.value);
      try {
        const res = await fetch('/api/scheduleMessage', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ greeting, body, price, lockedText, mediaFiles, previews, recipients: fansData.map(f => f.id), scheduledTime })
        });
        const result = await res.json();
        if (res.ok && result.success) {
          alert('Message scheduled.');
        } else {
          alert('Error scheduling message: ' + (result.error || res.statusText));
        }
      } catch (err) {
        console.error('Error scheduling message:', err);
      }
    }

    document.getElementById('refreshBtn').addEventListener('click', refreshFansList);
    document.getElementById('updateBtn').addEventListener('click', updateParkerNames);
    document.getElementById('sendBtn').addEventListener('click', sendMessagesToAll);
    document.getElementById('scheduleBtn').addEventListener('click', scheduleMessages);
    document.getElementById('loadVaultBtn').addEventListener('click', loadVaultMedia);
    document.getElementById('abortBtn').addEventListener('click', function() {
      if (sendingInProgress) {
        abortFlag = true;
        document.getElementById('statusMsg').innerText = 'Aborting...';
        this.disabled = true;
      }
    });
    document.getElementById('clearStatusBtn').addEventListener('click', clearStatusDots);
    document.getElementById('downloadBtn').addEventListener('click', downloadResults);

    document.getElementById('sizeSelect').addEventListener('change', e => applySize(e.target.value));
    document.getElementById('colorSelect').addEventListener('change', e => applyColor(e.target.value));
    document.getElementById('boldBtn').addEventListener('click', applyBold);
    document.getElementById('italicBtn').addEventListener('click', applyItalic);
    document.getElementById('placeholderSelect').addEventListener('change', e => {
      const val = e.target.value;
      if (val) {
        insertPlaceholder(val);
        e.target.value = '';
      }
    });

    // On page load, fetch any existing fans from the database
    fetchFans();
  </script>
</body>
</html>
