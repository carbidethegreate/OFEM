<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>OFEM Bulk Uploads</title>
<style>
body { font-family: Arial, sans-serif; margin: 20px; }
#drop-area { border: 2px dashed #ccc; border-radius: 10px; padding: 30px; text-align: center; color: #666; }
#gallery { margin-top: 20px; display: flex; flex-direction: column; gap: 10px; }
.item { display: flex; align-items: flex-start; border: 1px solid #ddd; padding: 10px; gap: 10px; }
.item img { max-width: 200px; height: auto; }
.caption-input { flex: 1; height: 100px; }
.schedule-input { width: 200px; }
.upload-status { font-size: 12px; color: #444; margin-top: 6px; }
.upload-status .error { color: #c00; font-weight: 600; }
.hidden { display: none; }
</style>
</head>
<body>
<h1>Bulk Image Upload</h1>
<p>Drag and drop images below or click to select files. After uploading, captions will be auto generated via ChatGPT.</p>
<div id="drop-area">
  <input type="file" id="fileElem" multiple accept="image/*" style="display:none;">
  <p>Drag & Drop Files Here</p>
  <button id="fileSelect">Select Files</button>
</div>
<div id="gallery"></div>
<button id="generateCaptions">Generate Captions</button>
<button id="retryUploads" class="hidden">Retry Failed Uploads</button>
<button id="schedulePosts">Schedule Posts</button>
<div id="statusMessage" role="status"></div>

<script>
// Basic drag-and-drop handling
const dropArea = document.getElementById('drop-area');
const fileElem = document.getElementById('fileElem');
const fileSelect = document.getElementById('fileSelect');
const gallery = document.getElementById('gallery');
const statusMessage = document.getElementById('statusMessage');
const retryUploadsButton = document.getElementById('retryUploads');
const scheduleButton = document.getElementById('schedulePosts');
let filesToUpload = [];
let uploadResults = [];
let uploadErrorMessage = '';
let batchId = null;
let itemsFromServer = [];
let hasUploadFailures = false;

fileSelect.addEventListener('click', () => fileElem.click());

fileElem.addEventListener('change', handleFiles, false);
dropArea.addEventListener('dragover', (e) => {
  e.preventDefault();
  dropArea.classList.add('hover');
});
dropArea.addEventListener('dragleave', () => dropArea.classList.remove('hover'));
dropArea.addEventListener('drop', (e) => {
  e.preventDefault();
  dropArea.classList.remove('hover');
  handleFiles({ target: { files: e.dataTransfer.files } });
});

function handleFiles(event) {
  const files = event.target.files;
  for (const file of files) {
    if (!file.type.startsWith('image/')) continue;
    filesToUpload.push(file);
    const previewUrl = URL.createObjectURL(file);
    const div = document.createElement('div');
    div.className = 'item';
    div.innerHTML = `
      <img src="${previewUrl}" alt="${file.name}">
      <textarea class="caption-input" placeholder="Caption for ${file.name}"></textarea>
      <div style="display:flex; flex-direction:column; gap:6px; min-width:200px;">
        <input class="schedule-input" placeholder="Schedule date/time" disabled>
        <div class="upload-status" aria-live="polite"></div>
      </div>
    `;
    gallery.appendChild(div);
  }
}

let scheduleData = [];

function renderUploadStatuses(items) {
  const itemEls = document.querySelectorAll('#gallery .item');
  items.forEach((item, idx) => {
    const statusEl = itemEls[idx]?.querySelector('.upload-status');
    if (!statusEl) return;
    statusEl.innerHTML = '';
    if (item.uploadStatus === 'success' && (item.imageUrl || item.url)) {
      statusEl.append('Upload successful: ');
      const link = document.createElement('a');
      link.href = item.imageUrl || item.url;
      link.target = '_blank';
      link.rel = 'noopener noreferrer';
      link.textContent = 'Preview';
      statusEl.appendChild(link);
    } else if (item.uploadStatus === 'failed') {
      const err = document.createElement('span');
      err.className = 'error';
      err.textContent = `Upload failed: ${item?.error?.message || 'Unknown error'}`;
      statusEl.appendChild(err);
    } else {
      statusEl.textContent = 'Upload pending...';
    }
  });
}

function updateScheduleControls(items) {
  hasUploadFailures = items.some(
    (item) => !item || item.uploadStatus === 'failed' || !item.imageUrl,
  );
  scheduleButton.disabled = hasUploadFailures;
  retryUploadsButton.classList.toggle('hidden', !hasUploadFailures);
  retryUploadsButton.disabled = !batchId;
}

document.getElementById('generateCaptions').addEventListener('click', async () => {
  if (filesToUpload.length === 0) {
    alert('Please select images first.');
    return;
  }
  statusMessage.textContent = 'Generating captions...';
  uploadResults = [];
  const formData = new FormData();
  filesToUpload.forEach((file) => formData.append('images', file));

  try {
    const response = await fetch('/api/bulk-upload', {
      method: 'POST',
      body: formData
    });
    if (!response.ok) {
      let errorDetail = `Failed to generate captions: ${response.status}`;
      try {
        const errorJson = await response.json();
        if (errorJson?.error) {
          errorDetail = `${errorDetail} - ${errorJson.error}`;
        }
      } catch (parseErr) {
        // ignore
      }
      throw new Error(errorDetail);
    }
    const data = await response.json();
    if (data.error && !data.uploadErrors) throw new Error('Failed to generate captions');
    const uploads = Array.isArray(data.uploads) ? data.uploads : [];
    const items = Array.isArray(data.items) ? data.items : [];
    const schedule = Array.isArray(data.schedule) ? data.schedule : [];
    if (uploads.length !== filesToUpload.length) {
      throw new Error('Upload response missing media references');
    }
    const captionInputs = document.querySelectorAll('.caption-input');
    const scheduleInputs = document.querySelectorAll('.schedule-input');
    // Prefer the richer items array (includes imageUrl)
    const sourceArray = items.length ? items : data.captions || [];
    sourceArray.forEach((c, idx) => {
      if (captionInputs[idx]) captionInputs[idx].value = c.caption;
    });
    batchId = data.batchId || null;
    itemsFromServer = items;
    uploadResults = uploads;
    scheduleData = items.length ? items : schedule;
    const scheduleToRender = items.length ? items : schedule;
    scheduleToRender.forEach((s, idx) => {
      if (scheduleInputs[idx] && s.sendAt) {
        const dateObj = new Date(s.sendAt);
        scheduleInputs[idx].value = dateObj.toLocaleString();
      }
    });
    if (items && items.length) {
      renderUploadStatuses(items);
      updateScheduleControls(items);
    }
    const uploadErrors = Array.isArray(data.uploadErrors)
      ? data.uploadErrors.filter(Boolean)
      : [];
    const cloudflareError = data.cloudflareError || uploadErrors[0] || null;
    uploadErrorMessage = cloudflareError?.message || '';
    if (cloudflareError) {
      statusMessage.textContent = `Captions generated, but uploads failed: ${uploadErrorMessage}`;
    } else {
      const successes = items.filter((i) => i.uploadStatus === 'success').length;
      const failures = items.filter((i) => i.uploadStatus === 'failed').length;
      statusMessage.textContent = `Captions generated. ${successes} upload(s) ready${failures ? `, ${failures} failed` : ''}.`;
    }
  } catch (err) {
    console.error(err);
    statusMessage.textContent = err?.message || 'Failed to generate captions.';
  }
});

retryUploadsButton.addEventListener('click', async () => {
  if (!batchId) {
    statusMessage.textContent = 'No batch to retry. Please generate captions again.';
    return;
  }
  statusMessage.textContent = 'Retrying failed uploads...';
  try {
    const res = await fetch('/api/bulk-upload/retry', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ batchId }),
    });
    if (!res.ok) {
      const text = await res.text();
      throw new Error(`Retry failed: ${res.status} - ${text}`);
    }
    const data = await res.json();
    batchId = data.batchId || batchId;
    itemsFromServer = Array.isArray(data.items) ? data.items : itemsFromServer;
    uploadResults = Array.isArray(data.uploads) ? data.uploads : uploadResults;
    scheduleData = Array.isArray(data.schedule) ? data.schedule : scheduleData;
    renderUploadStatuses(itemsFromServer);
    updateScheduleControls(itemsFromServer);
    const remainingFailures = itemsFromServer.filter((i) => i.uploadStatus === 'failed').length;
    if (remainingFailures) {
      statusMessage.textContent = `Retry completed. ${remainingFailures} upload(s) still failing.`;
    } else {
      statusMessage.textContent = 'Retry successful. All uploads ready to schedule.';
    }
  } catch (err) {
    console.error(err);
    statusMessage.textContent = err?.message || 'Retry failed.';
  }
});

document.getElementById('schedulePosts').addEventListener('click', async () => {
  if (!scheduleData || scheduleData.length === 0) {
    alert('Please generate captions first.');
    return;
  }
  if (!uploadResults || uploadResults.length === 0) {
    alert('Uploads missing. Please regenerate captions to refresh uploads.');
    return;
  }
  if (hasUploadFailures) {
    statusMessage.textContent = 'Retry failed uploads before scheduling.';
    return;
  }
  statusMessage.textContent = 'Scheduling posts...';
  try {
    const items = Array.from(document.querySelectorAll('#gallery .item'));
    const posts = items.map((item, idx) => {
      const upload = uploadResults[idx];
      const itemFromServer = itemsFromServer[idx] || {};
      const url =
        itemFromServer.imageUrl ||
        itemFromServer.url ||
        (upload && upload.url) ||
        null;
      const captionEl = item.querySelector('.caption-input');
      const scheduleFromApi = scheduleData[idx] && scheduleData[idx].sendAt;
      return {
        image_url: url,
        caption: captionEl ? captionEl.value : '',
        schedule_time: scheduleFromApi || null
      };
    });
    const persistRes = await fetch('/api/scheduled-posts', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        posts,
        batchId,
        retryMissingUploads: true,
      })
    });
    if (!persistRes.ok) {
      let errorMessage = `Failed to schedule posts: ${persistRes.status}`;
      try {
        const bodyText = await persistRes.text();
        console.error('schedule posts failed', persistRes.status, bodyText);
        const parsed = JSON.parse(bodyText);
        if (parsed?.error) errorMessage = parsed.error;
      } catch (e) {
        console.error('Failed to parse schedule error', e);
      }
      throw new Error(errorMessage);
    }
    const responseBody = await persistRes.json();
    if (!responseBody.success) throw new Error(responseBody?.error || 'Failed to schedule posts');
    const scheduleResults = Array.isArray(responseBody.scheduleResults)
      ? responseBody.scheduleResults
      : [];
    const scheduledCount = scheduleResults.filter((r) => r.status === 'scheduled').length;
    const skippedCount = scheduleResults.filter((r) => r.status === 'skipped').length;
    statusMessage.textContent = `Posts scheduled! Saved ${scheduledCount} item(s)${skippedCount ? `, ${skippedCount} skipped due to missing uploads` : ''}.`;
  } catch (err) {
    console.error(err);
    statusMessage.textContent = 'Failed to schedule posts.';
  }
});
</script>
</body>
</html>
